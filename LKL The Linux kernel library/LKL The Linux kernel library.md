# LKL: The Linux kernel library

[LKL_The_Linux_kernel_library.pdf](LKL_The_Linux_kernel_library.pdf)

LKL의 지향점 : 

- 특정 운영체제에 의존하지 않고 사용할 수 있어야 한다.
- user space와 kernel space 모두에서 사용 가능해야 한다.
- 리눅스 커널 트리의 최신 변경 사항을 쉽게 추적할 수 있어야 한다.
- 애플리케이션 입장에서 glue code가 최소한이어야 한다.
- 애플리케이션 개발자를 위한 안정적이고 사용하기 쉬운 API를 제공해야 한다.

LKL은 UML과 유사하게 리눅스 커널을 가상 컴퓨터 아키텍처(lkl)에 포팅한 형태로 구현.

⇒ 리눅스 커널의 핵심 구성 요소(core kernel components)**는 변경할 필요가 없음.

LKL은 환경에 구애받지 않는 설계를 목표로 하기 때문에, LKL 아키텍처에서는 플랫폼 의존코드(platform dependent code)를 전혀 사용하지 않는다.

대신 애플리케이션 측에서 작은 수의 환경 의존 함수를 구현해야 한다.

⇒ 이 함수들을 native operations라고 부르며,

⇒ 이 함수들을 바탕으로 LKL 아키텍처는 가상 머신을 구성하게 된다. 

LKL을 단일 애플리케이션 전용으로 쓰기 떄문에

리눅스 몇 가지 기본 기능이 LKL에서는 필요하지 않았다.

- 여러 사용자 주소 공간들 간의 주소 공간 분리 및 보호는 필요하지 않음.
- 커널에서 제공하는 사용자 공간 추상화 기능들조차도 필요하지 않음.

덕분에 구조를 단순화할 수 있으며, LKL을 직접 애플리케이션에 link시킬 수 있다.

### 1. Memory Management Support

커널이 메모리 할당에 사용할 수 있는 물리적 메모리. 이 메모리 풀은 애플리케이션이 직접 할당하고, 그 크기도 제어한다.

풀 내의 메모리는 커널이 자체적으로 관리하며, 일반 리눅스 시스템과 마찬가지로 buddy, SLUUB / SLAB / SLOB / SLQB 알고리즘을 조합해 사용한다.

LKL은 MMU가 없음. 

### 2. Thread support

LKL은 사용자 프로세스는 지원할 필요가 없지만 커널 스레드는 반드시 지우너해야함. 내부 작업(I/O, soft IRQ, workqueue등)

환경의 지원 없이 LKL 내부적으로 스레드를 구현하려했지만, 여러 제약 사항 존재.

(리눅스 커널은 스택 사용량이 깊기 때문에 스택 크기가 제한된 환경에서는 스레드 수에 제약, 환경의 도움을 일정 부분 요구)

스레드 구현 자체를 애플리케이션에 맡김. 

스레드 생성을 애플리케이션이 직접 생성하고, 스케줄링은 LKL 내부 로직 + 환경에 맡김.

### 3. Thread switching

LKL에서 사용되는 스레드는 환경에 의해 스케줄리되지만, 리눅스 커널은 스레드의 스케줄링을 직접 제어할 수 있어야 제대로 작동하고 효율을 낼 수 있다. (커널 라이브러리이기 때문에 CPU 스케줄링 권한이 없다.)

예) 리눅스의 스레드들은 **리눅스 세마포어와 동기화**되므로, 환경의 스케줄러가 아닌 **커널 자체가 제어** 할 수 있어야 합니다.

이를 위해 LKL 아키텍처 계층은 각 LKL 스레드마다 환경이 제공하는 세마포어를 연결한다. 

새 스레드가 생성되면, 리눅스 코드를 실행하기 전, 해당 스레드는 자신의 세마포어를 획득하면서 대기 상태가 된다. 

리눅스 스케줄러가 새로운 스레드를 선택하면, 새 스레드의 세마포어를 release하고, 이전 스레드의 세마포어를 acquire하며 block시킨다.

LKL이 **자체적으로 CPU를 스케줄링하지 못하기 때문에** 환경 세마포어를 활용해 선택된 스레드만 세마포어를 통해 실행 허가를 받는다.