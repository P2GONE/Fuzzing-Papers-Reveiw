# papora

[](https://ieeexplore.ieee.org/document/10188651)

### 서론

Janus, Hydra와 같은 파일 시스템 퍼저는 존재하지만 NTFS3에 직접적으로 적용할 수는 없었다. 

[기존 연구의 한계점]

1. NTFS 이미지를 파싱하기 위한 전용 파서가 없기 때문에 메타 데이터 추출, checksum 보정, corpus 구성이 불가능하다. 또한 기존의 NTFS 파서를 그대로 사용한는 것도 불가능한데, 그 이유는 이러한 파서들이 단순히 이미지 무결성만을 검증할 뿐이며, 이는 퍼징 테스트에 충분하지 않다. 
2. LKL에 kasan을 지원하지 않기 떄문에 취약점 탐지 효율이 떨어진다. 

[papora의 해결점]

1. NTFS가 오픈소스가 아님에도 불구하고, 여러 서드파티 릴리즈와 그에 해당하는 문서를 수작업으로 비교하고, 어떤 구현이 기대되는 동장과 일치하는지를 교차 참조하여 NTFS3 파서를 만듦. 
2. LKL을 적용함. 또 최신 버전으로 포팅하고 KASAN을 활성화함. 
⇒ 기존 KASAN은 MMU 기반 시스템에 맞춰져있기 떄문에 KASAN을 코드베이스를 수작업으로 리팩토링하여 no MMU LKL과 호환되게 만들었다. 

[실험 결과]

papora는 3개의 제로데이 CVE와 9개의 심각한 버그를 찾았다. 총 12개의 취약점은 모두 확인되었고 그 중 9개는 upstream에 반영되었다. 

우리의 연구는 **최신 리눅스에서의 NTFS 구현이 여전히 out-of-bounds 읽기 버그와 null 포인터 역참조 버그 문제를 겪고 있음을 보여줍니다.**
또 CASE STUDY를 진행 

[요약]

1. 리눅스에서 NTFS3를 대상으로 한 최초의 fuzzer 구현 
2. 3개의 CVE와 9개의 심각한 버그를 식별, 그 중 9개는 upstream에서 확인 및 수정 
3. NTFS3에서 발견된 버그들에 대해 퍼징 기반의 실증적 사례 분석을 수행 
4. 최신 LKL 포팅, KASAN을 통합한 papora 공개 

## 본론

### NTFS3란?

2021년에 등장으로, 리눅스 5.15 커널부터 NTFS의 강력한 기능을 활용가능 

NTFS 파일 시스템의 신뢰성 

- 하나는 **다른 저널링(journaling) 파일 시스템과 마찬가지로**, **로그 기록(logging)**과 **체크포인트(checkpoint)** 메커니즘을 활용하여, **시스템 예기치 않은 크래시 시에도 파일 시스템의 일관성을 보장**한다는 점입니다.
- 다른 하나는 **클러스터 재매핑(cluster remapping)**이라는 **복구 기법**을 통해 신뢰성을 향상시킵니다. 예를 들어, **읽기 작업 중 클러스터 내에서 불량 섹터(bad sector)**가 발견되면, NTFS는 해당 클러스터를 **새로 할당된 클러스터로 재매핑**하고, **불량 클러스터는 다시 사용되지 않도록 표시**합니다.

![스크린샷, 2025-07-18 16-21-51.png](%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7_2025-07-18_16-21-51.png)

- PBS : 시스템 부팅을 위한 중요한 부트스트랩 정보를 담고 있음
- MFT : 모든 파일과 디렉터리의 메타데이터를 저장, MFT 자신에 대한 메타데이터도 포함 
무결성을 보장하기 위해 MFT을 유지하며ㅡ 원본 MFT와 동일한 데이터를 저장 
MFT는 여러 개의 엔트리로 구성되며, 각 엔트리는 고정된 기능을 가지고 엄격한 문법을 따른다.
    - 세 번째 엔트리 $LogFile은 시스템 충돌 시 빠른 복구를 위한 모든 트랜잭션 기록
    - 일곱 번쨰 엔트리 $Bitmap은 모든 클러스터의 사용 여부를 나타내는 비트맵을 유지
- MFT가 파일 복구 필욯,ㄴ 메타 정보를 포함하고 있음.
- NTFS에서 각 파일은 클러스터 단위로 저장되며, 하나 이상의 섹터로 구성된 클러스터로 이루어진다.
파일 속성 목록의 형태로 구조화되며, 여기에는 파일 이름, 타임 스탬프, 실제 데이터 등이 포함된다.
    - MFT에 포함되지 않은 파일 데이터는 File System Data 영역에 저장된다.

 

### 퍼징이란?

[Coverage Based Fuzzer]

AFL, Libfuzzer : 컴파일할 때 instrumentation 추가, 실행 중의 대상 상태를 input mutator로 피드백하여, 퍼저가 이전과 다른 새로운 실행 경로를 지속적으로 탐색하도록 유도함. 

user space의 일반적인 프로그램을 퍼징할 때 : 명령행 인자나 설정 파일을 통해 변형된 입력을 전달하고, 해당 프로그램이 이를 반복 실행하며 crash가 발생할 때 까지 진행됨. 

[OS 구성 요소 퍼징]

2차원 입력 공간으로 확장됨.

1. 파일 시스템이 포함된 디스크 이미지 
2. 일련의 system call 시퀀스 입력 

Trinity나 Syzkaller와 같은 전통적인 kernel fuzzer는 여러 개의 시스템 콜과 그에 따른 파라미터들을 입력으로 생성하여 대상 OS를 테스트한다. 

특히, Trinity는 각 시스템 콜에 대해 주석(annotation)을 사용하여 무작위보다 더 효과적인 파라미터를 생성함으로써 예기치 않은 동작을 더 쉽게 유발할 수 있도록 설계함. 

Syzkaller는 KCOV를 통해 코드 커버리지를 수집하고, Syzlang을 통해 퍼징을 유도하기 위한 콘택스를 제공한다. 그러나, 파일 시스템은 훨씬 더 복잡한 입력이기 때문에 기존의 커널 퍼저들로는 효율적으로 생성하기 어렵ㄴ다. Janus와 Hydra는 파일 시스템 전용 파서를 이용해 대형 이미지에서 메타데이터를 추출함으로써 이 문제에 대응한다. 

특히 janus는 OS aging문제를 LKL을 통해 해결했다. LKL은 매번 초기화된 운영체제를 빠르게 로딩할 수 있어 재현되지 않은 버그 문제를 해결했다. 

### 도전과제

1. 디스크 이미지 

AFL같은 경우 권장되는 입력 크기는 1KB 미만이다. 하지만 빈 파일 시스템 조차도 디스크 이미지에 포함될 경우 수십 메가바이트 이상인 경우가 많다. 이처럼 큰 이미지를 직접 퍼지앟게되면, 이미지를 변형되거나 부팅하는 과정에서 발생하는 무거운 IO로 퍼징의 효율이 급격히 저하된다. 

1. 컨텍스트 인식 파일 작업 

파일 시스템은 이미지의 현재 상태(context)를 고려한 작업들이다. 이런 컨텍스트 인식 파일 작업들은 시드 변이 공간을 기하급수적으로 확장시키고, 이미지의 상태도 동시에 업데이트되어야 한다. 

예를 들어 open으로 fd를 생성하고 close로 해당 fd를 종료했다고하자. close이후 이전 fd를 사용한 syscall은 무의미한 작업들이 된다. 

1. 재현성 

전통 운영체제 퍼저들은 가상 인스턴스를 타깃으로 사욯안다. 하지만 가상 인스턴스를 자주 수정하거나 재부팅하거나 특정 스냅샷으로 롤백하는 작업은 매우 긴 시간이 소요된다. 

게다가 동일한 파일 시스템을 재사용하게 되면, aging problem이 발생할 수 있으며, 

이는 발견된 버그의 재현성을 어렵게 만들고, 퍼징의 신뢰성과 효율성을 심각하게 저해한다. 

Janus와 Hydra는 ext4, HFS+ 같은 파일 시스템에 대해 어느정도 해결했다. 

하지만 NTFS는 구현체가 부재한다. 

즉, 실제 구현체는 존재하지 않으며, closed되어 third-party에 의해 개발된 구현체 뿐이다. 

따라서 NTF 이미지를 효율적이고 정확하게 퍼징하는 것은 어려운 도전과제다. 

### 개요

Papora는 이런 문제들을 해결한 퍼저다. 

1. NTFS파서로 주어진 디스크 이미지를 스캔
2. 코퍼스를 생성하여 Papora로 전달 
3. Papora는 주어진 이미지의 메타데이터와 파일 작업들로 이루어진 프로그램을 mutate 
4. status field 갱신 
5. 변형된 결과는 다시 NTFS 파서에 의해 완전한 형태의 변형된 이미지로 조립되고 LKL에 의해 다시 mount되며 해당 프로그램에 따라 실행됨. 
6. 실행 라운드 결과가 마지막으로 출력되며, 그 피드백 정보는 다시 Papora로 전달하여 이후의 입력 변형을 안내함. 

### Corpus 생성

코퍼스는 3가지 구성 요소를 담고 있다.

- 주어진 이미지에서 추출한 메타데이터
- file operation으로 구성된 프로그램
- status file

NTFS 파서는 이미지로 부터 메타데이터를 추출하여, 하나의 압축된 데이터를 만든다. 

이러한 방식은 기존의 99%이상을 차지하는 이미지 내에 File System Data를 코퍼스에서 제외함으로써 불필요한 데이터 처리 비용을 줄이는 효과를 가져온다. 

프로그램은 아무 작업도 없는 빈 파일 작업 시퀀스로 시작한다. 

파일과 디렉토리 속성은 MFT에 저장된다. 이미지를 스캔하는 과정에서 이러한 속성들은 코퍼스의 세 번쨰 구성요소인 status file에 pack된다. 

Papora는 메타데이터나 파일 작업 중 하나를 mutate하고 이미지를 마운트한 뒤 프로그램을 실행하여 버그가 발생하는지 확인한다. 만약 발생하지 않는다면, 입력된 코퍼스의 해당 필드를 갱신한 뒤, 다음 라운드의 퍼징을 위해 전달된다. 

### NTFS 파서

1. 파서는 모든 메타데이터를 추출하여 하나의 조밀한 데이터 덩어리로 압축한다. 
    
    ⇒ 파일 시스템에서 이미지를 마운트 한 후 크래시가 발생하는 경우, 버그가 있는 메타데이터 떄문. 이는 전체 공간의 1%만 차지함. 즉, 나머지 99% 공간을 변형하는 것은 버그 탐지에 무의미함. 
    
    NTFS 같은 경우 메타데이터는 주로 PBS와 MFT에 있는 필드로 구성되어 있음. 
    
    따라서 **PBS와 MFT 내의 메타데이터를 추출하고 압축함.** 
    
    - mutate와 퍼징 효율성 증진
    - 손상된 메타데이터와 관련된 버그 발견 가능성 높임
2. 파서는 메타데이터가 mutate된 후 자동으로 checksum을 수정함. 
    
    ⇒ NTFS를 포함한 대부분의 파일 시스템은 메타데이터의 무결성과 사용 가능성을 보장하기 이ㅜ해 체크섬을 사용한다. 기존 체크섬 값과 실시간으로 계산된 체크섬 값이 일치하지 않으면 에러가 발생하며, 이미지가 제대로 로드되지 않게 된다. 
    
    따라서, 메타데이터를 mutate한 후 파서는 관련된 모든 체크섬을 재계산하여 mutate된 NTFS 가 체크섬 검사를 통과할 수 있도록 보장한다. 
    
    ex) 
    
    PBS : boot에 중요한 정보를 담고 있으며, OEM ID는 NTFS라는 문자열 4개가 이어지는 고정값. 
    
    MFT : 모든 파일 및 디렉터리의 메타데이터를 저장함. 각 파일 레코드의 헤더는 USN과 버퍼를 포함한다. NTFS는 각 레코드의 섹터 마지막 2바이트를 버퍼에 복사한 후 해당 위치에 USN값을 기록함. 부팅 후 NTFS는 헤더의 USN 값과 각 세터의 마지막 2바이트를 비교하여 무결성을 검증함. 
    
3. 퍼징 과정은 완전한 이미지 위에서 수행됨. 파서는 코퍼스에 있는 변형된 메타데이터를 다시 이미지에 정확히 매핑하는 역할 또한 수행함. 메타데이터를 추출하는 동안, 파서는 각 메타데이터 조각의 오프셋을 기록한 비트맵을 유지한다. 
    
    ⇒ 이 비트맵을 기반으로 변형된 메타데이터를 원래 위치에 다시 삽입 
    

기존의 파서 : NTFS 이미지를 파싱하고 로드하는 기능. 하지만 이는 단지 주어진 이미지가 유효한지 검사할 뿐이며, 이미지가 유효하지 않으면 로드가 되지 않음.

papora의 파서 : 체크섬을 수정하고  퍼징을 위한 코퍼스를 조립. 즉, 단순한 유효성 검증을 넘어서 추가적인 수정 과정까지 수행함. 

### Fuzzing Image

bit/byte flip, arithmetic operations등의 전략을 사용함. 

임의의 offset 비트 뒤집기, 임의의 오프셋에서 임의의 값을 더하거나 빼기, 임의의 길이만큼 랜덤 바이트 또는 chunk로 덮어 쓰기 등. 

메타데이터 mutate후 체크섬을 다시 계산함. 

`

### Fuzzing File Operations

- Mutation
    - 시드 하나 무작위로 선택 후 argument 일부를 무작위 값이 아닌 heurisitic한 값으로 교체
    - context-aware 작업. 즉 선택된 값은 현재 이미지 상태에 대해 의미 있는 값이어야함.
- Generation
    - 커버리지가 증가되지 않는다면, operation을 하나 추가함.
    - 이 과정에서 side effect도 고려되며, context역시 함께 업데이트됨.

### LKL

- 최신 리눅스 커널로 업그레이드. KASAN을 LKL에 통합함. 일부 인터페이스가 새로 추가되거나 변경되거나 제거되었기 때문에 최신 버전으로 포팅하기 까도로움.
- LKL은 No MMU. LKL은 linear memory address만 지원하는데, 이는 KASAN의 초기화 흐름과 충돌함. 따라서, KASAN의 초기화 흐름을 수작업으로 검토하고, 관련 코드나 구조체를 조정하거나 주석처리하여 KASAN의 기능을 유지하면서도 LKL과 호환되도록함.

장점 

1. VM보다 가볍기 때문에 재시작 소요 시간이 VM보다 빠름. 
2. 커널이 크래시되거나 노화되는 상태가 도달할 수 있음. 하지만 Papora는 코퍼스마다 executor를 재시작할 수 있어, 항상 안정적이고 결정적인 커널 상태를 유지함. 
3. 컴퓨팅 자원을 훨씬 적게 소모함.  

## 실험 결과

### 결과

VMware 8core CPU 16GB 메모리 우분투 16.04에서 수행함. 3달간의 실험이 이루어짐. 

9개의 심각한 버그와 3개의 CVE를 찾음. 

발견된 버그는 2가지로 분류됨. 

- NTFS 이미지를 마운트하는 즉시, 시스템이 크래시
- 이미지 마운투 후, 특정 시스템 콜을 호출해야만 크래시가 발생

Papora가 식별한 버그 중 

60% 이상은 OOB 읽기 버그임. 

25%는 null pointer 역참조 버그임.  

이 외에도 2개의 힙 손상 버그도 발견하였으며, UAF로 발전시킬 가능성이 있었음. 

### Root Cause

대부분의 원인은 사용제어 가능한 데이터에 대한 검증의 누락이었음.

파일 시스템 이미지로부터 추출된 모든 데이터 필드는 사용자 제어 가능한 데이터이므로, NTFS3 구현의 입력으로 사용되기 때문에 엄격한 검증이 있어야함. 

예를 들어, 특정 offset 필드가 조작되어 있고, 그 값이 메타데이터를 캐시하기 위해 할당된 메모리의 크기 제한을 벗어난다면, 그것만 해도 OOB Read를 유발할 수 있다. 

더 나아가, 만약 해당 offset이 다른 필드로 부터 계산되었다면, (number of entries) x (size of entry)가 충분히 크다면 overflow된 offset을 임의로 만들 수 있다. 

type confusion 인한 버그도 식별헀음. 이는 inode 설계 방식에서 기인함.

예를 들어 각 inode는 그 상태나 플래그에 따라 서로 다른 방식으로 해석될 수 있음. 

struct ntfs_inode내이 union은 각 ntfs_inode가 디렉터리 또는 파일 주 ㅇ하나로 해석되게 만듦.